#!/usr/bin/env node

/**
 * Build-Time Command Registry Generator
 *
 * Scans command directories and generates a static registry with all command imports and metadata.
 *
 * Supported structures:
 * - Legacy: src/presentation/cli/commands/{category}/{entity}.{action}.ts
 * - Clean Screaming: src/presentation/cli/{category}/{namespace}/{action}/{entity}.{action}.ts
 *
 * This runs during `npm run build` to create a fast, zero-overhead command registry.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.join(__dirname, '..');
const CLI_DIR = path.join(ROOT_DIR, 'src', 'presentation', 'cli');
const COMMANDS_DIR = path.join(CLI_DIR, 'commands');
const OUTPUT_FILE = path.join(ROOT_DIR, 'src', 'presentation', 'cli', 'shared', 'registry', 'generated-commands.ts');

// Clean Screaming Architecture directories to scan
// Import paths are relative from shared/registry/ to feature folders (../../)
const CLEAN_SCREAMING_DIRS = [
  { dir: path.join(CLI_DIR, 'work'), importPrefix: '../../work' },
  { dir: path.join(CLI_DIR, 'solution'), importPrefix: '../../solution' },
  { dir: path.join(CLI_DIR, 'project-knowledge'), importPrefix: '../../project-knowledge' },
  { dir: path.join(CLI_DIR, 'relations'), importPrefix: '../../relations' },
  { dir: path.join(CLI_DIR, 'maintenance'), importPrefix: '../../maintenance' }
];

/**
 * Recursively find all .ts files in a directory
 */
function findCommandFiles(dir, baseDir = dir) {
  const files = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...findCommandFiles(fullPath, baseDir));
    } else if (entry.isFile() && entry.name.endsWith('.ts')) {
      // Get relative path from commands directory
      const relativePath = path.relative(baseDir, fullPath);
      files.push(relativePath);
    }
  }

  return files;
}

/**
 * Parse command path from file path
 * Examples:
 *   "work/goal.start.ts" â†’ { parent: "goal", subcommand: "start", fullCommand: "goal start" }
 *   "project-knowledge/audiencePain.add.ts" â†’ { parent: "audience", subcommand: "pain add", fullCommand: "audience pain add" }
 */
function parseCommandPath(filePath) {
  const filename = path.basename(filePath, '.ts');
  const parts = filename.split('.');

  if (parts.length < 2) {
    throw new Error(`Invalid command filename: ${filePath}. Expected format: <parent>.<subcommand>[.<action>].ts`);
  }

  // First part is always parent, rest is subcommand
  const parent = parts[0];
  const subcommand = parts.slice(1).join(' ');
  const fullCommand = `${parent} ${subcommand}`;

  return {
    parent,
    subcommand,
    fullCommand
  };
}

/**
 * Generate import statement for a command
 * @param filePath - Relative path to the command file
 * @param importPrefix - The import path prefix (e.g., '../commands' or '../work')
 */
function generateImport(filePath, importPrefix) {
  // Convert file path to import path (remove .ts, use forward slashes)
  const importPath = filePath.replace(/\.ts$/, '.js').replace(/\\/g, '/');

  const { parent, subcommand, fullCommand } = parseCommandPath(filePath);

  // Create handler name by camelCasing the command parts
  // "goal start" â†’ "goalStart"
  // "audience pain add" â†’ "audiencePainAdd"
  const commandParts = fullCommand.split(' ');
  const handlerName = commandParts[0] + commandParts.slice(1).map(capitalize).join('');
  const metaName = `${handlerName}Meta`;

  return {
    statement: `import { ${handlerName}, metadata as ${metaName} } from '${importPrefix}/${importPath}';`,
    handlerName,
    metaName,
    parent,
    subcommand,
    fullCommand
  };
}

/**
 * Generate the registry file
 * @param commandFilesWithPrefix - Array of { filePath, importPrefix, baseDir }
 */
function generateRegistry(commandFilesWithPrefix) {
  const imports = commandFilesWithPrefix.map(({ filePath, importPrefix }) =>
    generateImport(filePath, importPrefix)
  );

  const importStatements = imports.map(imp => imp.statement).join('\n');

  const commandEntries = imports.map(imp => {
    return `  {
    path: '${imp.fullCommand}',
    metadata: ${imp.metaName},
    handler: ${imp.handlerName}
  }`;
  }).join(',\n');

  return `/**
 * Auto-generated Command Registry
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Generated by: scripts/generate-command-registry.mjs
 *
 * To regenerate: npm run generate:commands
 */

import { RegisteredCommand } from './CommandMetadata.js';

${importStatements}

export const commands: RegisteredCommand[] = [
${commandEntries}
];
`;
}

/**
 * Capitalize first letter
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Check if a command file has metadata export
 * Reads the file and looks for "export const metadata" or "export { metadata }"
 * @param filePath - Relative path from baseDir
 * @param baseDir - Base directory to resolve the full path
 */
function hasMetadataExport(filePath, baseDir) {
  try {
    const fullPath = path.join(baseDir, filePath);
    const content = fs.readFileSync(fullPath, 'utf-8');

    // Look for metadata export patterns:
    // - export const metadata: CommandMetadata = ...
    // - export const metadata = ...
    // - export { metadata }
    const metadataPattern = /export\s+(const\s+metadata|{\s*metadata\s*})/;
    return metadataPattern.test(content);
  } catch (error) {
    console.warn(`   Warning: Could not read ${filePath}: ${error.message}`);
    return false;
  }
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸ” Scanning for command files...');

  const allCommandFilesWithPrefix = [];
  let totalFiles = 0;
  let pendingMetadata = 0;

  // 1. Scan legacy commands directory
  if (fs.existsSync(COMMANDS_DIR)) {
    const legacyFiles = findCommandFiles(COMMANDS_DIR);
    totalFiles += legacyFiles.length;
    console.log(`   Legacy commands/ directory: ${legacyFiles.length} files`);

    const legacyWithMetadata = legacyFiles.filter(file => hasMetadataExport(file, COMMANDS_DIR));
    pendingMetadata += legacyFiles.length - legacyWithMetadata.length;

    legacyWithMetadata.forEach(file => {
      allCommandFilesWithPrefix.push({
        filePath: file,
        importPrefix: '../../commands',
        baseDir: COMMANDS_DIR
      });
    });
  }

  // 2. Scan Clean Screaming Architecture directories
  for (const { dir, importPrefix } of CLEAN_SCREAMING_DIRS) {
    if (fs.existsSync(dir)) {
      const cleanFiles = findCommandFiles(dir);
      totalFiles += cleanFiles.length;
      console.log(`   Clean Screaming ${path.basename(dir)}/ directory: ${cleanFiles.length} files`);

      const cleanWithMetadata = cleanFiles.filter(file => hasMetadataExport(file, dir));
      pendingMetadata += cleanFiles.length - cleanWithMetadata.length;

      cleanWithMetadata.forEach(file => {
        allCommandFilesWithPrefix.push({
          filePath: file,
          importPrefix,
          baseDir: dir
        });
      });
    }
  }

  console.log(`   Total: ${allCommandFilesWithPrefix.length} commands with metadata`);

  // Generate registry
  console.log('ðŸ“ Generating command registry...');
  const registryContent = generateRegistry(allCommandFilesWithPrefix);

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write registry file
  fs.writeFileSync(OUTPUT_FILE, registryContent, 'utf-8');
  console.log(`âœ… Generated: ${path.relative(ROOT_DIR, OUTPUT_FILE)}`);
  console.log(`   Registered ${allCommandFilesWithPrefix.length} commands`);
  if (pendingMetadata > 0) {
    console.log(`   (${pendingMetadata} files pending metadata migration)`);
  }
}

main();
